#+TITLE:  Org-Lectures
#+PROPERTY: header-args :tangle (let ((org-use-tag-inheritance t)) (if (member "INACTIVE" (org-get-tags))  "no" "org-lectures.el"))
#+auto_tangle: t

Header
#+begin_src elisp
;;; org-lectures.el --- Chasing simplicity -*- lexical-binding: t -*-

;; This file has been generated from the literate.org file. DO NOT EDIT.
;; Sources are available from https://github.com/chatziiola/org-lectures

;; Copyright (C) 2022-2025 Lamprinos Chatziioannou

;; Author: Lamprinos Chatziioannou
;; Maintainer: Lamprinos Chatziioannou
;; URL: https://github.com/chatziiola/org-lectures

;; Special thanks to:
;; - Gilles Castel (https://castel.dev)
;; - Jethro Kuan (https://github.com/jethrokuan)
;; - David Wilson (https://github.com/daviwil)
;; - Nicolas P. Rougier (https://github.com/rougier)
;; They inspired me not only to modify the "vanilla" setup and create scripts
;; for myself, but also to catch the "bug" of making my setups reproducible and
;; proper—giving back to the amazing Emacs, Org, and FOSS communities.

;; This file is NOT part of GNU Emacs.

#+end_src

License
#+begin_src elisp
;; LICENSE

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

#+end_src

#+begin_src elisp
;;; Commentary:

;; For a deep dive into the ideology of the package, look up the README.org file
;; that you should have received along with it.

#+end_src

* Imports
Let's dive into the code
#+begin_src elisp
;;; Code:

(require 'org)
(require 'org-lectures-index) ;; Makes this fast enough
(require 'org-lectures-latex) ;; Provides latexmk integration

#+end_src

* Available variables
For those wishing to customize their installation:

#+begin_src elisp
(defvar org-lectures-dir (expand-file-name "~/org/lectures")
 "Lecture and course files directory.

All courses and their respective lecture files are stored in
subfolders.")

(defvar org-lectures-default-institution "A.U.Th"
  "Default institution to be used on lecture creation.

This variable should be set once, when starting to use this
note-taking setup.

Setting the property INSTITUTION properly in the course
information file will cause all lectures for that course to be
created with that property (thus overwriting this variable).

Even though it certainly is not always useful, it helps automate
most of the lecture notes for any undergrad.")

(defvar org-lectures-current-semester "5"
  "Holds current semester value.

To be updated at the beginning of each semester by the user. This
option is not necessary but helps in the /automatic/ gathering of
data around courses.")

(defvar org-lectures-static-course-files-dir  org-lectures-dir
  "The path to extra course-related subfolders.

This option defaults to `org-lectures-dir'. Thus,
combining the two folders, of static information and
lectures (note-taking) into a single folder. Check the README.org
file for more information on the thinking process behind this
choice.")

(defvar org-lectures-org-roam-id-integration t
  "Whether `org-lectures-dir' is a subdirectory of `org-roam-directory'.

If this is true, then upon file creation a unique ID will be
generated, so that course files can be linked and use from within
org-roam.

FIXME. This option is not currently implemented.")



#+end_src


<2023-04-17 Mon>: New parameter: Note type:
#+begin_src elisp
(defvar org-lectures-note-type-alist '(("lecture" . "lec"))
  "Contains the note type. Every pair here will be checked.

The format is '(key . regex).

TODO: Implement it in note creation.
"
  )
#+end_src

<2025-10-25 Sat>: New parameter: Lecture file template
#+NAME: org-lecture-file-template
#+begin_src elisp
(defvar org-lectures-file-template
  ":PROPERTIES:
:ID: %i
:END:
,#+TITLE: %T
,#+FILETAGS: %t
,#+DATE: %d
,#+COURSE: %c
,#+INSTITUTION: %I
,#+PROFESSOR: %P
"
  "Template for new lecture files.

Use `format-spec` codes:
  %i  -> ID (e.g., \"lec-<course>-\")
  %d  -> date (e.g., \"<2025-10-25>\")
  %c  -> course
  %I  -> institution
  %P  -> professor
  %t  -> filetags
  %T  -> title")

(defvar org-lectures-course-file-template
  ":PROPERTIES:
:ID: %i
:END:
#+TITLE: %T
#+PROFESSOR: %P
#+INSTITUTION: %I
#+SEMESTER: %s
#+FILETAGS: course
#+COURSE: %c
"
  "Template for new course files.

Use `format-spec` codes:
  %i  -> ID (e.g., \"<course>-course\")
  %c  -> course
  %I  -> institution
  %s  -> semester
  %T  -> title
  %P  -> professor")
#+end_src

<2025-10-25 Sat>: New parameter: Lecture default tags
#+NAME: org-lectures-default-tag-alist
#+begin_src elisp
(defvar org-lectures-default-tag-alist '("lecture" "todo")
  "This variable is used when setting the FILETAGS parameter in new lecture files")

(defvar org-lectures-after-create-course-hook nil
  "Hook run after creating a new course.
The course ID is passed as an argument.")

(defvar org-lectures-after-open-course-hook nil
  "Hook run after opening an existing course file.
The filename of the course is passed as an argument.")

(defvar org-lectures-after-create-lecture-hook nil
  "Hook run after creating a new lecture.
The filename of the new lecture is passed as an argument.")

(defvar org-lectures-after-open-lecture-hook nil
  "Hook run after opening an existing lecture.
The filename of the lecture is passed as an argument.")
#+end_src


** Configuring index

#+begin_src elisp
(with-eval-after-load 'org-lectures-index
  (setq org-lectures-index-dir org-lectures-dir)
  (setq org-lectures-index-note-type-alist org-lectures-note-type-alist))
#+end_src
* Functions
** String Normalization
Inspired by `org-roam`, this package utilizes a slug function. Rather than reimplementing similar functionality, an existing solution was adapted.
- Source:  https://github.com/org-roam/org-roam
- <2025-10-25 Sat>: I opted for a much simpler version:
  - Keeps only alphanumeric characters - discards everything else.
  - Uses '-' for spaces.
#+begin_src elisp
(defun org-lectures-sluggify (s)
  "Given a string, return its 'sluggified' version.

Essentially it is:
- all lowercase letters and '-' instead of spaces
- thus: no spaces or special characters

It has only one argument, INPUTSTRING, which is self-explanatory"
    (let* ((s (downcase (string-trim s)))
           (s (replace-regexp-in-string "[^[:alnum:][:space:]-]" "" s))
           (s (replace-regexp-in-string "[[:space:]]+" "-" s)))
      (replace-regexp-in-string "^-\\|-$" "" s)))
#+end_src

Note on performance:
- Earlier implementations that used `(kill-buffer)` to manage open buffers led to significantly reduced performance. While the current approach might still incur some initial delay when processing a new category, it avoids the performance overhead of frequent buffer creation and destruction.

** Finding a Course
Find-course: This is the entry point
#+begin_src elisp

(defun org-lectures-find-course ()
  "Default driver function of `org-lectures.el'."
  (interactive)
  (let* ((course-answer (org-lectures-select-course-from-list)))
    (cond
     ((string-equal course-answer "NC")
      (org-lectures-create-new-course))
     (t
      (org-lectures-find-course-lectures (upcase course-answer))))))

#+end_src

** Selecting a Course from the List
Select course from course prompt
- This needs to be optimized inline.
- Make it "internal"
#+begin_src elisp
(defun org-lectures-select-course-from-list ()
  "Show a prompt and return the selected course's ID."
  (let ((courses (org-lectures-index-get-course-list)))
    (if (not courses)
        (let ((selection (completing-read "Select Course: " '("New Course"))))
          (if (string-equal selection "New Course") "NC" nil))
      (let* (;; Dynamic column widths for pretty alignment
             (max-title-width (apply #'max 0 (mapcar (lambda (c) (length (or (plist-get (cdr c) :title) ""))) courses)))
             (max-prof-width (apply #'max 0 (mapcar (lambda (c) (length (or (plist-get (cdr c) :professor) ""))) courses)))
             (max-inst-width (apply #'max 0 (mapcar (lambda (c) (length (or (plist-get (cdr c) :institution) ""))) courses)))
             (vertico-p (and (fboundp 'vertico-mode) vertico-mode))
             (format-string-vertico (format "%%-5s %%-%ds │ %%-%ds │ %%-%ds" max-title-width max-prof-width max-inst-width))
             (format-string-default (format "%%-5s %%-%ds %%-%ds %%-%ds" max-prof-width max-title-width max-inst-width))
             (course-prompt-alist
              (append
               (mapcar
                (lambda (c)
                  (let* ((course-plist (cdr c))
			 (course-id (or (plist-get course-plist :course-id) ""))
                         (professor (or (plist-get course-plist :professor) ""))
                         (title (or (plist-get course-plist :title) ""))
                         (institution (or (plist-get course-plist :institution) "")))
                    (cons (if vertico-p
                              (format format-string-vertico course-id title professor institution)
                            (format format-string-default course-id professor title institution))
                          course-id)))
                courses)
               (list (cons "New Course" "NC")))))
        (let* ((selected-prompt (completing-read "Select Course: " course-prompt-alist)))
          (cdr (assoc selected-prompt course-prompt-alist)))))))
#+end_src

#+RESULTS:
: org-lectures-select-course-from-list

** Creating a New Course
Create new course:
#+begin_src elisp
(defun org-lectures--create-new-course-internal (course &optional title professor institution semester)
  "Internal function to create a new course with given COURSE short title.
Creates the course info file and updates the index. Does not prompt for input.
Returns the path to the created course file."
  (let* ((course-org-file (org-lectures-index-get-course-file course))
	 (id (concat course "-course"))
	 (title (or title ""))
	 (professor (or professor ""))
	 (institution (or institution org-lectures-default-institution))
	 (semester (or semester org-lectures-current-semester))
	 (spec (format-spec-make '?i id '?c course '?I institution '?s semester '?T title '?P professor))
	 (payload (format-spec org-lectures-course-file-template spec t)))
    (write-region payload nil course-org-file)
    (run-hook-with-args 'org-lectures-after-create-course-hook course)
    course-org-file))

(defun org-lectures-create-new-course ()
  "Interactively create a new course.
Prompts the user for a short course title (up to 4 characters).
Creates the course info file and opens it, and updates the index."
  (interactive)
  (let* ((course (upcase (completing-read "Insert short course title:" ())))
         (course-org-file (org-lectures-index-get-course-file course)))
    (cond ((file-exists-p course-org-file)
	   (org-lectures-find-course-lectures course))
	  ((<= (length course) 4)
	   (let ((created-file (org-lectures--create-new-course-internal course)))
             (org-open-file created-file)))
	  (t
	   (error "Invalid Course Name. Short title must be less than 5 characters long")))))
#+end_src

** Opening the Course Folder
- Relies on internal function of ~org-lectures-index~: ~-get-keyword-value~
#+begin_src elisp

(defun org-lectures-open-course-folder (&optional course)
  "Open the selected course's folder (with system default).

Works only if inside an org file with the 'COURSE' property, or
when called by `org-lectures-find-course-lectures'"
  (interactive)
  (let* ((course (or course (org-lectures-index--get-keyword-value "COURSE"))))
    (unless (symbolp course)
      (message (concat "Course " course " folder opened"))
      (shell-command (concat "open " org-lectures-static-course-files-dir "course_" course)))))

(defun org-lectures-dired-course-folder (&optional course)
  "Open the selected course's folder (with Dired).

Works only if inside an org file with the 'COURSE' property, or
when called by `org-lectures-find-course-lectures'"
  (interactive)
  (message "org-lectures-dired-course-folder function will be deprecated in a later version")
  (let* ((course (or course (org-lectures-index--get-keyword-value "COURSE"))))
    (unless (symbolp course)
      (message (concat "Course " course " folder opened")))
    (dired (concat org-lectures-static-course-files-dir "course_" course))))

#+end_src

- <2025-10-25 Sat> Deprecated message dired-course-folder. No reason to exist,
  since keybindings for dired do this much more easily.

** Opening a Course and Listing Lectures
#+begin_src elisp

(defun org-lectures-find-course-lectures (course)
  "Get prompt for COURSE lectures.

Open a minibuffer, using `org-lectures-select-lecture-from-course' in which the
user can filter the selected course's lectures, selecting an existing one, or
creating a new one. Gives the option to:
1. Create new lecture
2. Open an already existing lecture
3. Open the course's folder
4. Open the course's info file `course_<course>.org'."
  (let* ((lecture-answer (org-lectures-select-lecture-from-course course)))
    (if (stringp lecture-answer)
	(cond
	 ((string-equal lecture-answer "NL")
	  (org-lectures-create-new-lecture course))
	 ((string-equal lecture-answer "OF")
	  (org-lectures-dired-course-folder course))
	 ((string-equal lecture-answer "INFO")
	  (let ((course-file (org-lectures-index-get-course-file course)))
	    (org-open-file course-file)
	    (run-hook-with-args 'org-lectures-after-open-course-hook course-file))))
      (let ((lecture-file (plist-get (cdr lecture-answer) :file)))
        (org-open-file lecture-file)
        (run-hook-with-args 'org-lectures-after-open-lecture-hook lecture-file)))))
#+end_src

** Retrieving Lecture Selection
#+begin_src elisp
(defun org-lectures-select-lecture-from-course (course &optional publish)
  "Open a COURSE lecture for viewing or create a new one."
  (let* ((course-lectures (org-lectures-index-get-course-lectures-list course)))
    (if (not course-lectures)
        (let ((selection (completing-read "Select Lecture: " '("New Lecture" "Open Course Folder" "Course Info"))))
          (cond ((string-equal selection "New Lecture") "NL")
                ((string-equal selection "Open Course Folder") "OF")
                ((string-equal selection "Course Info") "INFO")
                (t nil)))
      (let* ((max-date-width (apply #'max 0 (mapcar (lambda (l) (length (or (plist-get (cdr l) :date) ""))) course-lectures)))
             (max-title-width (apply #'max 0 (mapcar (lambda (l) (length (or (plist-get (cdr l) :title) ""))) course-lectures)))
             (max-prof-width (apply #'max 0 (mapcar (lambda (l) (length (or (plist-get (cdr l) :professor) ""))) course-lectures)))
             (vertico-p (and (fboundp 'vertico-mode) vertico-mode))
             (format-string
              (if vertico-p
                  (format "%%-%ds │ %%-%ds │ %%-%ds" max-date-width max-title-width max-prof-width)
                (format "%%-%ds %%-%ds %%-%ds" max-date-width max-title-width max-prof-width)))
             (lecture-prompt-list
              (append
               (mapcar
                (lambda (l)
                  (let ((title (or (plist-get (cdr l) :title) ""))
                        (professor (or (plist-get (cdr l) :professor) ""))
                        (date (or (plist-get (cdr l) :date) "")))
                    (cons (format format-string date title professor) l)))
                course-lectures)
               (unless publish
                 (list '("New Lecture" . "NL")
                       '("Open Course Folder" . "OF")
                       '("Course Info" . "INFO"))))))
        (let* ((selected-prompt (completing-read "Select Lecture: " lecture-prompt-list)))
          (cdr (assoc selected-prompt lecture-prompt-list)))))))
#+end_src

#+RESULTS:
: org-lectures-select-lecture-from-course

** Creating a New Lecture
- [ ] Opening a newly created lecture does not run the after open hook
#+NAME: Name
#+begin_src elisp
(defun org-lectures-generate-lecture-id (course &optional time)
  "Generate a unique id for a new lecture.
COURSE is the course identifier. TIME is an optional time value
to use for the timestamp, defaulting to the current time."
  (concat "lec-" course "-" (format-time-string "%Y%m%d%H%M%S" (or time (current-time)))))
#+end_src


- Still using internal index function: ~--get-keyword-value~
#+begin_src elisp
(defun org-lectures--create-new-lecture-internal (course lecture-title lecture-professor lecture-institution note-type date-str &optional suffix)
  "Internal function to create a new lecture.
COURSE: The course short title.
LECTURE-TITLE: The title of the lecture.
LECTURE-PROFESSOR: The professor's name.
LECTURE-INSTITUTION: The institution name.
NOTE-TYPE: The short note type (e.g., 'lec').
DATE-STR: The date string (e.g., '20251216').
SUFFIX: Optional suffix for filename collision resolution.
Returns the path to the created lecture file."
  (let* ((lecture-filename (expand-file-name
			    (org-lectures--set-lectures-filename-internal course note-type date-str suffix)
			    (org-lectures-index-get-course-dir course))))
    (let* ((id   (org-lectures-generate-lecture-id course))
	   (date (format "<%s-%s-%s>" (substring date-str 0 4) (substring date-str 4 6) (substring date-str 6 8)))
	   (tags (string-join (seq-map (lambda (x) (cond ((stringp x) x) ((consp x) (car x)) (t nil))) org-lectures-default-tag-alist) " "))
	   (spec (format-spec-make '?i id ?d date ?c course ?I lecture-institution ?P lecture-professor ?t tags ?T lecture-title))
	   (payload (format-spec org-lectures-file-template spec t)))
      (write-region payload nil lecture-filename)
      (run-hook-with-args 'org-lectures-after-create-lecture-hook lecture-filename)
      lecture-filename)))

(defun org-lectures-create-new-lecture (&optional course)
  "Interactively create a new lecture for COURSE.
Prompts for lecture title, note type, and handles filename collisions.
If COURSE is not provided, it will try to get it from the current buffer's context."
  (interactive "sCourse (current or default): ")
  (let* ((current-course (or course (org-lectures-index--get-keyword-value "COURSE")))
	 (courses (org-lectures-index-get-course-list))
         (actual-course (if (string-blank-p current-course)
                            (completing-read "Create lecture for course: " (mapcar #'car courses)) current-course))
	 (course-data (cdr (assoc actual-course courses)))
         (lecture-institution (or (plist-get course-data :institution) org-lectures-default-institution))
         (lecture-professor (or (plist-get course-data :professor) ""))
         (lecture-title (read-string "Lecture title: "))
         (note-type-key (completing-read "Note type: " (mapcar #'car org-lectures-note-type-alist)))
         (note-type (org-lectures--get-note-type-internal note-type-key))
         (date-str (format-time-string "%Y%m%d" (current-time)))
         (base-filename (org-lectures--set-lectures-filename-internal actual-course note-type date-str))
         (course-lectures-dir (org-lectures-index-get-course-dir actual-course))
         (full-path (expand-file-name base-filename course-lectures-dir))
         suffix)

    ;; Handle filename collision
    (when (file-exists-p full-path)
      (setq suffix (org-lectures--get-collision-suffix-internal (read-string "Filename suffix (empty for time): "))))

    (let ((created-file (org-lectures--create-new-lecture-internal
                         actual-course
                         lecture-title
                         lecture-professor
                         lecture-institution
                         note-type
                         date-str
                         suffix)))
      (org-open-file created-file))))
#+end_src

** Setting the Lecture Filename
#+begin_src elisp
(defun org-lectures--get-note-type-internal (note-type-key)
  "Return the regex for NOTE-TYPE-KEY from `org-lectures-note-type-alist'."
  (cdr (assoc note-type-key org-lectures-note-type-alist)))

(defun org-lectures--get-note-type ()
  "Interactively select a note type from `org-lectures-note-type-alist'."
  (interactive)
  (let ((types org-lectures-note-type-alist))
    (if (= (length types) 1)
        (cdar types)
      (let* ((prompt "Select a note type: ")
             (options (mapcar #'car types))
             (choice (completing-read prompt options)))
        (org-lectures--get-note-type-internal choice)))))

(defun org-lectures--get-collision-suffix-internal (user-input)
  "Return a formatted suffix string from USER-INPUT.
If USER-INPUT is blank, return current time, otherwise sluggify it."
  (if (string-blank-p user-input)
      (format-time-string "%H%M%S" (current-time))
    (org-lectures-sluggify user-input)))

(defun org-lectures--get-collision-suffix ()
  "Prompts the user for info if a lecture file exists, returning a filename suffix."
  (interactive)
  (let ((prompt "A lecture with this filename already exists. Enter supplementary information (leaving this empty appends the current time in HHMMSS format): "))
    (let ((user-input (read-string prompt)))
      (org-lectures--get-collision-suffix-internal user-input))))


(defun org-lectures--set-lectures-filename-internal (course note-type date-str &optional suffix)
  "Generate a lecture filename for COURSE.
NOTE-TYPE is the short type (e.g., 'lec').
DATE-STR is the date in YYYYMMDD format.
SUFFIX is an optional string to append for collision resolution."
  (if suffix
      (format "%s_%s_%s_%s.org" note-type course date-str suffix)
    (format "%s_%s_%s.org" note-type course date-str)))

(defun org-lectures-set-lectures-filename (course)
  "Return a unique lecture filename for COURSE.
Prompts for note type and collision suffix if necessary."
  (interactive "sCourse: ")
  (let* ((note-type (org-lectures--get-note-type))
         (date-str (format-time-string "%Y%m%d" (current-time)))
         (base-filename (org-lectures--set-lectures-filename-internal course note-type date-str))
         (course-dir (org-lectures-index-get-course-dir course))
         (full-path (expand-file-name base-filename course-dir)))
    (if (file-exists-p full-path)
        ;; Collision detected, get suffix interactively
        (let* ((suffix (org-lectures--get-collision-suffix)))
          (org-lectures--set-lectures-filename-internal course note-type date-str suffix))
      ;; No collision
      base-filename)))
#+end_src

** Footer
#+begin_src elisp
(provide 'org-lectures)
;;; org-lectures.el ends here
#+end_src
